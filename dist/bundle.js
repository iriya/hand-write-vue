/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./packages/core/dist/componentinstance.js":
/*!*************************************************!*\
  !*** ./packages/core/dist/componentinstance.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PublicInstanceProxyHandlers: () => (/* binding */ PublicInstanceProxyHandlers)\n/* harmony export */ });\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n\r\n\r\nconst PublicInstanceProxyHandlers = {\r\n  get(instance, key) {\r\n    const { ctx, data, props } = instance\r\n\r\n    // 判断是否是setup返回的对象\r\n    if (key[0] === \"$\") {\r\n      return\r\n    }\r\n\r\n    // 判断是否是data中的属性\r\n    if (data !== void 0 && (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(data, key)) {\r\n      return data[key]\r\n    }\r\n\r\n    // 判断是否是props中的属性\r\n    if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(props, key)) {\r\n      return props[key]\r\n    }\r\n\r\n    return ctx[key]\r\n  },\r\n  \r\n  set(instance, key, value) {\r\n    const { ctx, data } = instance\r\n\r\n    if (data !== void 0 && (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(data, key)) {\r\n      data[key] = value\r\n      return true\r\n    }\r\n\r\n    if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instance.props, key)) {\r\n      console.warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\r\n      return false\r\n    }\r\n\r\n    if (key[0] === '$' && key.slice(1) in instance) {\r\n      __DEV__ &&\r\n      console.warn(\r\n          `Attempting to mutate public property \"${key}\". ` +\r\n            `Properties starting with $ are reserved and readonly.`,\r\n        )\r\n      return false\r\n    } else {\r\n      ctx[key] = value\r\n    }\r\n    return true\r\n  },\r\n\r\n  has(instance, key) {\r\n    const { ctx, data } = instance;\r\n    return (\r\n      (data !== EMPTY_OBJ && (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(data, key)) ||\r\n      (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(ctx, key)\r\n    )\r\n  },\r\n}\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/componentinstance.js?");

/***/ }),

/***/ "./packages/core/dist/createapi.js":
/*!*****************************************!*\
  !*** ./packages/core/dist/createapi.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAppAPI: () => (/* binding */ createAppAPI)\n/* harmony export */ });\n/* harmony import */ var _vnode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnode.js */ \"./packages/core/dist/vnode.js\");\n\r\n\r\nconst createAppAPI = (render) => {\r\n  return function createApp(rootComponent, rootProps) {\r\n    const context = createAppContext()\r\n    let isMounted = false\r\n\r\n    const app = {\r\n      _component: rootComponent,\r\n      _props: rootProps,\r\n      _container: null,\r\n      _context: context,\r\n      mount(rootContainer) {\r\n        if (!isMounted) {\r\n          const vnode = (0,_vnode_js__WEBPACK_IMPORTED_MODULE_0__.createVNode)(rootComponent, rootProps)\r\n          vnode.appContext = context\r\n\r\n          render(vnode, rootContainer)\r\n          isMounted = true\r\n          app._container = rootContainer\r\n          rootContainer.__vue_app__ = app\r\n        }\r\n      } \r\n    }\r\n    return app\r\n  }\r\n}\r\n\r\nconst createAppContext = () => {\r\n  return {\r\n    config: {},\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/createapi.js?");

/***/ }),

/***/ "./packages/core/dist/dom.js":
/*!***********************************!*\
  !*** ./packages/core/dist/dom.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   nodeOps: () => (/* binding */ nodeOps)\n/* harmony export */ });\nconst doc = (typeof document !== 'undefined' ? document : null)\r\n\r\nconst nodeOps = {\r\n  normalizeContainer: (el) => {\r\n    return doc.querySelector(el)\r\n  },\r\n\r\n  insert: (child, parent, anchor) => {\r\n    parent.insertBefore(child, anchor || null)\r\n  },\r\n\r\n  remove: child => {\r\n    const parent = child.parentNode\r\n    if (parent) {\r\n      parent.removeChild(child)\r\n    }\r\n  },\r\n\r\n  createElement: (tag, namespace, is, props) => {\r\n    const el =\r\n      namespace === 'svg'\r\n        ? doc.createElementNS(svgNS, tag)\r\n        : namespace === 'mathml'\r\n          ? doc.createElementNS(mathmlNS, tag)\r\n          : is\r\n            ? doc.createElement(tag, { is })\r\n            : doc.createElement(tag)\r\n\r\n    if (tag === 'select' && props && props.multiple != null) {\r\n      ;(el).setAttribute('multiple', props.multiple)\r\n    }\r\n\r\n    return el\r\n  },\r\n\r\n  createText: text => doc.createTextNode(text),\r\n\r\n  createComment: text => doc.createComment(text),\r\n\r\n  setText: (node, text) => {\r\n    node.nodeValue = text\r\n  },\r\n\r\n  setElementText: (el, text) => {\r\n    el.textContent = text\r\n  },\r\n\r\n  parentNode: node => node.parentNode | null,\r\n\r\n  nextSibling: node => node.nextSibling,\r\n\r\n  querySelector: selector => doc.querySelector(selector),\r\n\r\n  setScopeId(el, id) {\r\n    el.setAttribute(id, '')\r\n  },\r\n\r\n  // __UNSAFE__\r\n  // Reason: innerHTML.\r\n  // Static content here can only come from compiled templates.\r\n  // As long as the user only uses trusted templates, this is safe.\r\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\r\n    // <parent> before | first ... last | anchor </parent>\r\n    const before = anchor ? anchor.previousSibling : parent.lastChild\r\n    // #5308 can only take cached path if:\r\n    // - has a single root node\r\n    // - nextSibling info is still available\r\n    if (start && (start === end || start.nextSibling)) {\r\n      // cached\r\n      while (true) {\r\n        parent.insertBefore(start.cloneNode(true), anchor)\r\n        if (start === end || !(start = start.nextSibling)) break\r\n      }\r\n    } else {\r\n      // fresh insert\r\n      templateContainer.innerHTML =\r\n        namespace === 'svg'\r\n          ? `<svg>${content}</svg>`\r\n          : namespace === 'mathml'\r\n            ? `<math>${content}</math>`\r\n            : content\r\n\r\n      const template = templateContainer.content\r\n      if (namespace === 'svg' || namespace === 'mathml') {\r\n        // remove outer svg/math wrapper\r\n        const wrapper = template.firstChild\r\n        while (wrapper.firstChild) {\r\n          template.appendChild(wrapper.firstChild)\r\n        }\r\n        template.removeChild(wrapper)\r\n      }\r\n      parent.insertBefore(template, anchor)\r\n    }\r\n    return [\r\n      // first\r\n      before ? before.nextSibling : parent.firstChild,\r\n      // last\r\n      anchor ? anchor.previousSibling : parent.lastChild,\r\n    ]\r\n  },\r\n}\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/dom.js?");

/***/ }),

/***/ "./packages/core/dist/index.js":
/*!*************************************!*\
  !*** ./packages/core/dist/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createApp: () => (/* reexport safe */ _vue_js__WEBPACK_IMPORTED_MODULE_0__.createApp),\n/* harmony export */   h: () => (/* reexport safe */ _vue_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reactive: () => (/* reexport safe */ _vue_js__WEBPACK_IMPORTED_MODULE_0__.reactive)\n/* harmony export */ });\n/* harmony import */ var _vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vue.js */ \"./packages/core/dist/vue.js\");\n\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/index.js?");

/***/ }),

/***/ "./packages/core/dist/patchprop.js":
/*!*****************************************!*\
  !*** ./packages/core/dist/patchprop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchProp: () => (/* binding */ patchProp)\n/* harmony export */ });\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n/* harmony import */ var _renderutils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderutils.js */ \"./packages/core/dist/renderutils.js\");\n\r\n\r\n\r\nconst patchProp = (el, key, prevValue, nextValue, parentComponent) => {\r\n  if (key === 'class') {\r\n    patchClass(el, nextValue)\r\n  } else if (key === 'style') {\r\n    patchStyle(el, prevValue, nextValue)\r\n  } else if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isOn)(key)) {\r\n    patchEvent(el, key, prevValue, nextValue, parentComponent)\r\n  }\r\n}\r\n\r\nconst patchClass = (el, value) => {\r\n  if (value == null) {\r\n    el.removeAttribute('class')\r\n  } else {\r\n    el.className = value\r\n  }\r\n}\r\n\r\nconst patchStyle = (el, prev, next) => {\r\n  const style = (el).style\r\n  const isCssString = (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isString)(next)\r\n  let hasControlledDisplay = false\r\n  if (next && !isCssString) {\r\n    if (prev) {\r\n      if (!(0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isString)(prev)) {\r\n        for (const key in prev) {\r\n          if (next[key] == null) {\r\n            setStyle(style, key, '')\r\n          }\r\n        }\r\n      } else {\r\n        for (const prevStyle of prev.split(';')) {\r\n          const key = prevStyle.slice(0, prevStyle.indexOf(':')).trim()\r\n          if (next[key] == null) {\r\n            setStyle(style, key, '')\r\n          }\r\n        }\r\n      }\r\n    }\r\n    for (const key in next) {\r\n      if (key === 'display') {\r\n        hasControlledDisplay = true\r\n      }\r\n      setStyle(style, key, next[key])\r\n    }\r\n  } else {\r\n    if (isCssString) {\r\n      if (prev !== next) {\r\n        // #9821\r\n        const cssVarText = (style)[CSS_VAR_TEXT]\r\n        if (cssVarText) {\r\n          ;(next) += ';' + cssVarText\r\n        }\r\n        style.cssText = next\r\n        hasControlledDisplay = displayRE.test(next)\r\n      }\r\n    } else if (prev) {\r\n      el.removeAttribute('style')\r\n    }\r\n  }\r\n  // indicates the element also has `v-show`.\r\n  if (vShowOriginalDisplay in el) {\r\n    // make v-show respect the current v-bind style display when shown\r\n    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : ''\r\n    // if v-show is in hidden state, v-show has higher priority\r\n    if ((el)[vShowHidden]) {\r\n      style.display = 'none'\r\n    }\r\n  }\r\n}\r\n\r\nconst setStyle = (style, name, val) => {\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(val)) {\r\n    val.forEach(v => setStyle(style, name, v))\r\n  } else {\r\n    if (val == null) val = ''\r\n    if (name.startsWith('--')) {\r\n      // custom property definition\r\n      style.setProperty(name, val)\r\n    } else {\r\n      const prefixed = autoPrefix(style, name)\r\n      if (importantRE.test(val)) {\r\n        // !important\r\n        style.setProperty(\r\n          (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(prefixed),\r\n          val.replace(importantRE, ''),\r\n          'important',\r\n        )\r\n      } else {\r\n        style[prefixed] = val\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst prefixes = ['Webkit', 'Moz', 'ms']\r\nconst prefixCache = {}\r\nconst autoPrefix = (style, rawName) => {\r\n  const cached = prefixCache[rawName]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n  let name = (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)\r\n  if (name !== 'filter' && name in style) {\r\n    return (prefixCache[rawName] = name)\r\n  }\r\n  name = (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.capitalize)(name)\r\n  for (let i = 0; i < prefixes.length; i++) {\r\n    const prefixed = prefixes[i] + name\r\n    if (prefixed in style) {\r\n      return (prefixCache[rawName] = prefixed)\r\n    }\r\n  }\r\n  return rawName\r\n}\r\n\r\nconst addEventListener = (el, event, handler, options) => {\r\n  el.addEventListener(event, handler, options)\r\n}\r\n\r\nconst removeEventListener = (el, event, handler, options) => {\r\n  el.removeEventListener(event, handler, options)\r\n}\r\n\r\nconst veiKey = Symbol('_vei')\r\nconst patchEvent = (el, rawName, prevValue, nextValue, instance) => {\r\n  // vei = vue event invokers\r\n  const invokers = el[veiKey] || (el[veiKey] = {})\r\n  const existingInvoker = invokers[rawName]\r\n  if (nextValue && existingInvoker) {\r\n    // patch\r\n    existingInvoker.value = sanitizeEventValue(nextValue, rawName)\r\n  } else {\r\n    const [name, options] = parseName(rawName)\r\n    if (nextValue) {\r\n      // add\r\n      const invoker = (invokers[rawName] = createInvoker(sanitizeEventValue(nextValue, rawName), instance))\r\n      addEventListener(el, name, invoker, options)\r\n    } else if (existingInvoker) {\r\n      // remove\r\n      removeEventListener(el, name, existingInvoker, options)\r\n      invokers[rawName] = undefined\r\n    }\r\n  }\r\n}\r\n\r\nlet cachedNow = 0\r\nconst p = /*#__PURE__*/ Promise.resolve()\r\nconst getNow = () =>\r\n  cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()))\r\nconst createInvoker = (initialValue, instance) => {\r\n  const invoker = (e) => {\r\n    // async edge case vuejs/vue#6566\r\n    // inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // this no longer happens for templates in Vue 3, but could still be\r\n    // theoretically possible for hand-written render functions.\r\n    // the solution: we save the timestamp when a handler is attached,\r\n    // and also attach the timestamp to any event that was handled by vue\r\n    // for the first time (to avoid inconsistent event timestamp implementations\r\n    // or events fired from iframes, e.g. #2513)\r\n    // The handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (!e._vts) {\r\n      e._vts = Date.now()\r\n    } else if (e._vts <= invoker.attached) {\r\n      return\r\n    }\r\n    (0,_renderutils_js__WEBPACK_IMPORTED_MODULE_1__.callWithAsyncErrorHandling)(\r\n      patchStopImmediatePropagation(e, invoker.value),\r\n      instance,\r\n      [e],\r\n    )\r\n  }\r\n  invoker.value = initialValue\r\n  invoker.attached = getNow()\r\n  return invoker\r\n}\r\n\r\nconst patchStopImmediatePropagation = (e, value) => {\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {\r\n    const originalStop = e.stopImmediatePropagation\r\n    e.stopImmediatePropagation = () => {\r\n      originalStop.call(e)\r\n      ;(e)._stopped = true\r\n    }\r\n    return (value).map(\r\n      fn => (e) => !(e)._stopped && fn && fn(e),\r\n    )\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\n\r\nconst sanitizeEventValue = (value, propName) => {\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value) || (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {\r\n    return value\r\n  }\r\n  warn(\r\n    `Wrong type passed as event handler to ${propName} - did you forget @ or : ` +\r\n      `in front of your prop?\\nExpected function or array of functions, received type ${typeof value}.`,\r\n  )\r\n  return _shared_js__WEBPACK_IMPORTED_MODULE_0__.NO_OP\r\n}\r\n\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/\r\nconst parseName = (name) => {\r\n  let options\r\n  if (optionsModifierRE.test(name)) {\r\n    options = {}\r\n    let m\r\n    while ((m = name.match(optionsModifierRE))) {\r\n      name = name.slice(0, name.length - m[0].length)\r\n      ;(options)[m[0].toLowerCase()] = true\r\n    }\r\n  }\r\n  const event = name[2] === ':' ? name.slice(3) : (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(name.slice(2))\r\n  return [event, options]\r\n}\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/patchprop.js?");

/***/ }),

/***/ "./packages/core/dist/reactive.js":
/*!****************************************!*\
  !*** ./packages/core/dist/reactive.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReactiveEffect: () => (/* binding */ ReactiveEffect),\n/* harmony export */   effect: () => (/* binding */ effect),\n/* harmony export */   reactive: () => (/* binding */ reactive)\n/* harmony export */ });\nconst reactive = (obj) => {\r\n  const proxy = new Proxy(obj, {\r\n    get(target, key, receiver) {\r\n      // 收集依赖\r\n      track(target, key)\r\n      return Reflect.get(target, key, receiver)\r\n    },\r\n    set(target, key, value, receiver) {\r\n      const res = Reflect.set(target, key, value, receiver)\r\n      // 触发依赖\r\n      trigger(target, key)\r\n      return res\r\n    }\r\n  })\r\n  return proxy\r\n}\r\n\r\nlet activeEffect = null\r\nconst effect = (fn) => {\r\n  const _effect = new ReactiveEffect(fn)\r\n  _effect.run()\r\n}\r\n\r\nclass ReactiveEffect {\r\n  constructor(fn) {\r\n    this.fn = fn\r\n    this.deps = []\r\n  }\r\n  run() {\r\n    activeEffect = this\r\n    this.fn()\r\n    activeEffect = null\r\n  }\r\n}\r\n\r\nconst targetMap = new WeakMap()\r\nconst track = (target, key) => {\r\n  if (activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Set()))\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n      dep.add(activeEffect)\r\n      activeEffect.deps.push(dep)\r\n    }\r\n  }\r\n}\r\n\r\nconst trigger = (target, key) => {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) return\r\n  const dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach(effect => {\r\n      effect.run()\r\n    })\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/reactive.js?");

/***/ }),

/***/ "./packages/core/dist/render.js":
/*!**************************************!*\
  !*** ./packages/core/dist/render.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   baseCreateRenderer: () => (/* binding */ baseCreateRenderer)\n/* harmony export */ });\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n/* harmony import */ var _createapi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createapi.js */ \"./packages/core/dist/createapi.js\");\n/* harmony import */ var _vnode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vnode.js */ \"./packages/core/dist/vnode.js\");\n/* harmony import */ var _reactive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reactive.js */ \"./packages/core/dist/reactive.js\");\n/* harmony import */ var _renderutils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderutils.js */ \"./packages/core/dist/renderutils.js\");\n/* harmony import */ var _componentinstance_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./componentinstance.js */ \"./packages/core/dist/componentinstance.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst baseCreateRenderer = (options) => {\r\n  const { insert, remove, patchProp, createElement, createText, createComment, setText, setElementText, parentNode, nextSibling, setScopeId = _shared_js__WEBPACK_IMPORTED_MODULE_0__.NO_OP, insertStaticContent } = options;\r\n  const render = (vnode, container) => {\r\n    if (vnode == null) {\r\n      if (container._vnode) {\r\n        unmount(container._vnode)\r\n      }\r\n    } else {\r\n      patch(container._vnode || null, vnode, container, null)\r\n    }\r\n    container._vnode = vnode\r\n  }\r\n  const unmount = (vnode, parentComponent, doRemove = false) => {\r\n    const { type, shapeFlag, children } = vnode\r\n    if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.COMPONENT) {\r\n      unmountComponent(vnode.component, parentComponent, doRemove)\r\n    } else {\r\n      unmountChildren(children, parentComponent, doRemove)\r\n      if (doRemove) {\r\n        removeFn(vnode)\r\n      }\r\n    }\r\n  }\r\n  const unmountComponent = (instance, parentComponent, doRemove) => {\r\n    const { subTree } = instance\r\n    unmount(subTree, instance, doRemove)\r\n  }\r\n  const removeFn = (vnode) => {\r\n    const { type, el } = vnode\r\n    if (type == _vnode_js__WEBPACK_IMPORTED_MODULE_2__.Types.Static) {\r\n\r\n    }\r\n    if (vnode.shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ELEMENT) {\r\n      remove(el)\r\n    }\r\n  }\r\n  const patch = (n1, n2, container, parentComponent = null) => {\r\n    if (n1 === n2) {\r\n      return\r\n    }\r\n    if (n1 && !isSameVNodeType(n1, n2)) {\r\n      unmount(n1)\r\n      n1 = null\r\n    }\r\n\r\n    const { type, shapeFlag } = n2\r\n    switch (type) {\r\n      case _vnode_js__WEBPACK_IMPORTED_MODULE_2__.Types.Text:\r\n        processText(n1, n2, container)\r\n        break\r\n      case _vnode_js__WEBPACK_IMPORTED_MODULE_2__.Types.Comment:\r\n        processComment(n1, n2, container)\r\n        break\r\n      case _vnode_js__WEBPACK_IMPORTED_MODULE_2__.Types.Static:\r\n        if (n1 == null) {\r\n          mountStaticNode(n2, container)\r\n        }\r\n        break\r\n      case _vnode_js__WEBPACK_IMPORTED_MODULE_2__.Types.Fragment:\r\n        processFragment(n1, n2, container)\r\n        break\r\n      default:\r\n        if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ELEMENT) {\r\n          processElement(n1, n2, container, parentComponent)\r\n        } else if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.COMPONENT) {\r\n          processComponent(n1, n2, container, parentComponent)\r\n        }\r\n    }\r\n  }\r\n\r\n  const processText = (n1, n2, container) => { }\r\n  const processComment = (n1, n2, container) => { }\r\n  const mountStaticNode = (n2, container) => { }\r\n  const processFragment = (n1, n2, container) => { }\r\n  const processElement = (n1, n2, container, parentComponent) => {\r\n    if (n1 == null) {\r\n      mountElement(n2, container, parentComponent)\r\n    } else {\r\n      patchElement(n1, n2, container, parentComponent)\r\n    }\r\n  }\r\n  const mountElement = (vnode, container, parentComponent) => {\r\n    let el\r\n    const { props, shapeFlag } = vnode\r\n    el = (vnode.el = createElement(vnode.type, null, props && props.is, props))\r\n    if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.TEXT_CHILDREN) {\r\n      setElementText(el, vnode.children)\r\n    } else if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ARRAY_CHILDREN) {\r\n      mountChildren(vnode.children, el, parentComponent)\r\n    }\r\n    if (props) {\r\n      for (const key in props) {\r\n        patchProp(el, key, null, props[key], parentComponent)\r\n      }\r\n    }\r\n    insert(el, container)\r\n  }\r\n  const unmountChildren = (children, parentComponent, doRemove = false, start = 0) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      unmount(children[i], parentComponent)\r\n    }\r\n  }\r\n  const mountChildren = (children, container, parentComponent, optimized, start = 0) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      const child = (children[i] = optimized\r\n        ? (0,_vnode_js__WEBPACK_IMPORTED_MODULE_2__.cloneIfMounted)(children[i])\r\n        : (0,_vnode_js__WEBPACK_IMPORTED_MODULE_2__.normalizeVNode)(children[i]))\r\n      patch(\r\n        null,\r\n        child,\r\n        container,\r\n        parentComponent\r\n      )\r\n    }\r\n  }\r\n  const patchElement = (n1, n2, container, parentComponent) => {\r\n    const el = n2.el = n1.el\r\n    const oldProps = n1.props || _shared_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ\r\n    const newProps = n2.props || _shared_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ\r\n    patchChildren(n1, n2, el, parentComponent)\r\n    patchProps(el, n2, oldProps, newProps)\r\n  }\r\n  const patchChildren = (n1, n2, container, parentComponent, optimized) => {\r\n    const c1 = n1 && n1.children\r\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\r\n    const c2 = n2.children\r\n    const { shapeFlag } = n2\r\n    if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.TEXT_CHILDREN) {\r\n      if (prevShapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ARRAY_CHILDREN) {\r\n        unmountChildren(c1, parentComponent)\r\n      }\r\n      if (c2 !== c1) {\r\n        setElementText(container, c2)\r\n      }\r\n    } else {\r\n      if (prevShapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ARRAY_CHILDREN) {\r\n        if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ARRAY_CHILDREN) {\r\n          patchKeyedChildren(c1, c2, container, parentComponent, optimized)\r\n        } else {\r\n          unmountChildren(c1, parentComponent, true)\r\n        }\r\n      } else {\r\n        // prev children was text OR null\r\n        // new children is array OR null\r\n        if (prevShapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.TEXT_CHILDREN) {\r\n          setElementText(container, '')\r\n        }\r\n        if (shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_2__.ShapeFlags.ARRAY_CHILDREN) {\r\n          mountChildren(c2, container, parentComponent, optimized)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  const patchKeyedChildren = (c1, c2, container, parentComponent, optimized) => {\r\n    const oldLength = c1.length\r\n    const newLength = c2.length\r\n    const commonLength = Math.min(oldLength, newLength)\r\n    for (let i = 0; i < commonLength; i++) {\r\n      const nextChild = (c2[i] = optimized\r\n        ? (0,_vnode_js__WEBPACK_IMPORTED_MODULE_2__.cloneIfMounted)(c2[i])\r\n        : (0,_vnode_js__WEBPACK_IMPORTED_MODULE_2__.normalizeVNode)(c2[i]))\r\n      patch(c1[i], nextChild, container, parentComponent)\r\n    }\r\n    if (oldLength > newLength) {\r\n      unmountChildren(c1, parentComponent, true, commonLength)\r\n    } else {\r\n      mountChildren(c2, container, parentComponent, optimized, commonLength)\r\n    }\r\n  }\r\n  const patchProps = (el, n2, oldProps, newProps) => {\r\n\r\n  }\r\n\r\n  const processComponent = (n1, n2, container, parentComponent) => {\r\n    if (n1 == null) {\r\n      mountComponent(n2, container, parentComponent)\r\n    } else {\r\n      patchComponent(n1, n2, parentComponent)\r\n    }\r\n  }\r\n  const mountComponent = (vnode, container, parentComponent) => {\r\n    const instance = (vnode.component = createComponentInstance(vnode, parentComponent))\r\n    setupComponent(instance)\r\n    setupRenderEffect(instance, vnode, container)\r\n  }\r\n  const patchComponent = (n1, n2, parentComponent) => { }\r\n  const createComponentInstance = (vnode, parent) => {\r\n    const type = vnode.type\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || null\r\n    const instance = {\r\n      vnode,\r\n      type,\r\n      parent,\r\n      appContext,\r\n      root: null,\r\n      next: null,\r\n      subTree: null,\r\n      render: null,\r\n      proxy: null,\r\n\r\n      // state\r\n      ctx: _shared_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,\r\n      data: _shared_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,\r\n      props: _shared_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,\r\n\r\n      // lifecycle\r\n      isMounted: false,\r\n      isUnmounted: false,\r\n    }\r\n    instance.ctx = instance\r\n    instance.root = parent ? parent.root : instance\r\n    return instance\r\n  }\r\n  const setupComponent = (instance) => {\r\n    const { props, children } = instance.vnode\r\n    initProps(instance, props)\r\n    initSlots(instance, children)\r\n    setupStatefulComponent(instance)\r\n  }\r\n  const initProps = (instance, rawProps) => { \r\n    const props = {}\r\n    const { defaultProps } = instance.type\r\n    if (defaultProps) {\r\n      for (let key in defaultProps) {\r\n        props[key] = defaultProps[key]\r\n      }\r\n    }\r\n    if (rawProps) {\r\n      for (let key in rawProps) {\r\n        props[key] = rawProps[key]\r\n      }\r\n    }\r\n    instance.props = props\r\n  }\r\n  const initSlots = (instance, children) => { }\r\n  const setupStatefulComponent = (instance) => {\r\n    instance.proxy = new Proxy(instance.ctx, _componentinstance_js__WEBPACK_IMPORTED_MODULE_5__.PublicInstanceProxyHandlers);\r\n    const { setup } = instance.type\r\n    if (setup) {\r\n      const setupResult = (0,_renderutils_js__WEBPACK_IMPORTED_MODULE_4__.callWithErrorHandling)(setup, instance, [instance.props])\r\n      if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isPromise)(setupResult)) {\r\n        setupResult.then(resolvedResult => handleSetupResult(instance, resolvedResult)).catch(e => (0,_renderutils_js__WEBPACK_IMPORTED_MODULE_4__.handleError)(e, instance))\r\n      } else {\r\n        handleSetupResult(instance, setupResult)\r\n      }\r\n    }\r\n  }\r\n  const handleSetupResult = (instance, setupResult) => {\r\n    if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(setupResult)) {\r\n      instance.render = setupResult\r\n    } else if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(setupResult)) {\r\n      if ((0,_vnode_js__WEBPACK_IMPORTED_MODULE_2__.isVNode)(setupResult)) {\r\n        console.warn(`setup() should not return VNodes directly - return a render function instead.`);\r\n      }\r\n      instance.setupState = setupResult\r\n    }\r\n  }\r\n\r\n  const setupRenderEffect = (instance, vnode, container) => {\r\n    const componentUpdateFn = () => {\r\n      if (!instance.isMounted) {\r\n        const { el, props } = vnode\r\n        const { parent } = instance\r\n        const subTree = (instance.subTree = (0,_renderutils_js__WEBPACK_IMPORTED_MODULE_4__.renderComponentRoot)(instance))\r\n        patch(null, subTree, container, instance)\r\n        vnode.el = subTree.el\r\n        instance.isMounted = true\r\n      } else {\r\n        let { next, parent, vnode } = instance\r\n        if (next) {\r\n          next.el = vnode.el\r\n        } else {\r\n          next = vnode\r\n        }\r\n        const nextTree = (0,_renderutils_js__WEBPACK_IMPORTED_MODULE_4__.renderComponentRoot)(instance)\r\n        const prevTree = instance.subTree\r\n        instance.subTree = nextTree\r\n        patch(prevTree, nextTree, parent?.el, instance)\r\n      }\r\n    }\r\n    const effect = (instance.effect = new _reactive_js__WEBPACK_IMPORTED_MODULE_3__.ReactiveEffect(componentUpdateFn))\r\n    const update = (instance.update = () => {\r\n      effect.run()\r\n    })\r\n    update()\r\n  }\r\n\r\n  const isSameVNodeType = (n1, n2) => {\r\n    return n1.type === n2.type\r\n  }\r\n\r\n  return {\r\n    render,\r\n    createApp: (0,_createapi_js__WEBPACK_IMPORTED_MODULE_1__.createAppAPI)(render)\r\n  }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/render.js?");

/***/ }),

/***/ "./packages/core/dist/renderutils.js":
/*!*******************************************!*\
  !*** ./packages/core/dist/renderutils.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   callWithAsyncErrorHandling: () => (/* binding */ callWithAsyncErrorHandling),\n/* harmony export */   callWithErrorHandling: () => (/* binding */ callWithErrorHandling),\n/* harmony export */   handleError: () => (/* binding */ handleError),\n/* harmony export */   renderComponentRoot: () => (/* binding */ renderComponentRoot)\n/* harmony export */ });\n/* harmony import */ var _vnode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnode.js */ \"./packages/core/dist/vnode.js\");\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n\r\n\r\n\r\nconst renderComponentRoot = (instance) => {\r\n  const {\r\n    type,\r\n    vnode,\r\n    render,\r\n    proxy,\r\n    props,\r\n    data,\r\n    ctx\r\n  } = instance\r\n\r\n  let result\r\n  try {\r\n    if (vnode.shapeFlag & _vnode_js__WEBPACK_IMPORTED_MODULE_0__.ShapeFlags.STATEFUL_COMPONENT) {\r\n      result = (0,_vnode_js__WEBPACK_IMPORTED_MODULE_0__.normalizeVNode)(render.call(proxy, ctx, props))\r\n    } else {\r\n      // functional\r\n      const render = type\r\n      result = (0,_vnode_js__WEBPACK_IMPORTED_MODULE_0__.normalizeVNode)(render.call(proxy, ctx, props))\r\n    }\r\n  } catch (err) {\r\n    handleError(err, instance)\r\n    result = (0,_vnode_js__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_vnode_js__WEBPACK_IMPORTED_MODULE_0__.Types.Comment)\r\n  }\r\n  return result\r\n}\r\n\r\nconst handleError = (err, instance) => {\r\n  console.error(err, instance)\r\n}\r\n\r\nconst callWithErrorHandling = (fn, instance, args) => {\r\n  try {\r\n    return args ? fn(...args) : fn()\r\n  } catch (err) {\r\n    handleError(err, instance)\r\n  }\r\n}\r\n\r\nconst callWithAsyncErrorHandling = (fn, instance, arg) => {\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\r\n    const res = callWithErrorHandling(fn, instance, arg)\r\n    if (res && isPromise(res)) {\r\n      res.catch(err => {\r\n        handleError(err, instance, type)\r\n      })\r\n    }\r\n    return res\r\n  }\r\n\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {\r\n    const values = []\r\n    for (let i = 0; i < fn.length; i++) {\r\n      values.push(callWithAsyncErrorHandling(fn[i], instance, arg))\r\n    }\r\n    return values\r\n  } else {\r\n    warn(\r\n      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`,\r\n    )\r\n  }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/renderutils.js?");

/***/ }),

/***/ "./packages/core/dist/shared.js":
/*!**************************************!*\
  !*** ./packages/core/dist/shared.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY_ARR: () => (/* binding */ EMPTY_ARR),\n/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   NO_OP: () => (/* binding */ NO_OP),\n/* harmony export */   camelize: () => (/* binding */ camelize),\n/* harmony export */   capitalize: () => (/* binding */ capitalize),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   hasOwn: () => (/* binding */ hasOwn),\n/* harmony export */   hyphenate: () => (/* binding */ hyphenate),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isDate: () => (/* binding */ isDate),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isIntegerKey: () => (/* binding */ isIntegerKey),\n/* harmony export */   isMap: () => (/* binding */ isMap),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isOn: () => (/* binding */ isOn),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   objectToString: () => (/* binding */ objectToString),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   toRawType: () => (/* binding */ toRawType),\n/* harmony export */   toTypeString: () => (/* binding */ toTypeString)\n/* harmony export */ });\nconst isMap = (val) =>\r\n  toTypeString(val) === '[object Map]'\r\nconst isSet = (val) =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nconst isDate = (val) =>\r\n  toTypeString(val) === '[object Date]'\r\nconst isRegExp = (val) =>\r\n  toTypeString(val) === '[object RegExp]'\r\n\r\nconst isObject = (obj) => {\r\n  return obj !== null && typeof obj === 'object'\r\n}\r\n\r\nconst isPromise = (val) => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val).then) &&\r\n    isFunction((val).catch)\r\n  )\r\n}\r\n\r\nconst objectToString = Object.prototype.toString\r\nconst toTypeString = (value) =>\r\n  objectToString.call(value)\r\n\r\nconst toRawType = (value) => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nconst isPlainObject = (val) =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nconst isIntegerKey = (key) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nconst isString = (obj) => {\r\n  return typeof obj === 'string'\r\n}\r\n\r\nconst isFunction = (obj) => {\r\n  return typeof obj === 'function'\r\n}\r\n\r\nconst isArray = Array.isArray\r\n\r\nconst EMPTY_OBJ = {}\r\nconst EMPTY_ARR = []\r\n\r\nconst NO_OP = () => {}\r\n\r\nconst extend = Object.assign\r\n\r\nconst isOn = (key) => \r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nconst remove = (arr, el) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nconst hasOwn = (\r\n  val,\r\n  key\r\n) => hasOwnProperty.call(val, key)\r\n\r\n\r\nconst cacheStringFunction = (fn) => {\r\n  const cache = Object.create(null)\r\n  return ((str) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  })\r\n}\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase(),\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1))\r\n})\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/shared.js?");

/***/ }),

/***/ "./packages/core/dist/vnode.js":
/*!*************************************!*\
  !*** ./packages/core/dist/vnode.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShapeFlags: () => (/* binding */ ShapeFlags),\n/* harmony export */   Types: () => (/* binding */ Types),\n/* harmony export */   cloneIfMounted: () => (/* binding */ cloneIfMounted),\n/* harmony export */   createVNode: () => (/* binding */ createVNode),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   isVNode: () => (/* binding */ isVNode),\n/* harmony export */   normalizeVNode: () => (/* binding */ normalizeVNode)\n/* harmony export */ });\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n\r\n\r\nconst ShapeFlags = Object.freeze({\r\n  ELEMENT: 1,\r\n  FUNCTIONAL_COMPONENT: 1 << 1,\r\n  STATEFUL_COMPONENT: 1 << 2,\r\n  TEXT_CHILDREN: 1 << 3,\r\n  ARRAY_CHILDREN: 1 << 4,\r\n  // SLOTS_CHILDREN: 1 << 5,\r\n  // TELEPORT: 1 << 6,\r\n  // SUSPENSE: 1 << 7,\r\n  // COMPONENT_SHOULD_KEEP_ALIVE: 1 << 8,\r\n  // COMPONENT_KEPT_ALIVE: 1 << 9,\r\n  COMPONENT: 1 << 2 | 1 << 1 /*ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT*/\r\n})\r\n\r\nconst Types = Object.freeze({\r\n  Text: Symbol('Text'),\r\n  Comment: Symbol('Comment'),\r\n  Static: Symbol('Static'),\r\n  Fragment: Symbol('Fragment')\r\n})\r\n\r\nconst isVNode = (vnode) => {\r\n  return vnode ? vnode.__v_isVNode === true : false\r\n}\r\n\r\nconst _createVNode = (type, props, children = null) => {\r\n  if (!type) {\r\n    type = Comment\r\n  }\r\n  if (isVNode(type)) {\r\n    const cloned = cloneVNode(type, props)\r\n    if (children) {\r\n      normalizeChildren(cloned, children)\r\n    }\r\n    return cloned\r\n  }\r\n  // if (isClassComponent(type)) {\r\n  //   type = type.__vccOpts\r\n  // }\r\n  // 2.x async/functional component compat\r\n\r\n  // class & style normalization.\r\n  // if (props) {\r\n  //   // for reactive or proxy objects, we need to clone it to enable mutation.\r\n  //   let { class: klass, style } = props\r\n  //   if (klass && !isString(klass)) {\r\n  //     props.class = normalizeClass(klass)\r\n  //   }\r\n  //   if (isObject(style)) {\r\n  //     // reactive state objects need to be cloned since they are likely to be\r\n  //     // mutated\r\n  //     if (isProxy(style) && !isArray(style)) {\r\n  //       style = extend({}, style)\r\n  //     }\r\n  //     props.style = normalizeStyle(style)\r\n  //   }\r\n  // }\r\n\r\n  // encode the vnode type information into a bitmap\r\n  const shapeFlag = (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isString)(type)\r\n    ? ShapeFlags.ELEMENT\r\n    : (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(type)\r\n      ? ShapeFlags.STATEFUL_COMPONENT\r\n      : (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(type)\r\n        ? ShapeFlags.FUNCTIONAL_COMPONENT\r\n        : 0\r\n  return createBaseVNode(type, props, children, shapeFlag, true)\r\n}\r\n\r\nconst normalizeChildren = (vnode, children) => {\r\n  let type = 0\r\n  if (children == null) {\r\n    children = null\r\n  } else if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(children)) {\r\n    type = ShapeFlags.ARRAY_CHILDREN\r\n  } else if (typeof children === 'object') {\r\n    // todo\r\n  } else if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(children)) {\r\n    // todo\r\n  } else {\r\n    children = String(children)\r\n    type = ShapeFlags.TEXT_CHILDREN\r\n  }\r\n  vnode.children = children\r\n  vnode.shapeFlag |= type\r\n}\r\n\r\nfunction h(type, propsOrChildren, children) {\r\n  let l = arguments.length\r\n  if (l === 2) {\r\n    if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(propsOrChildren) && !(0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(propsOrChildren)) {\r\n      if (isVNode(propsOrChildren)) {\r\n        return createVNode(type, null, [propsOrChildren]) // 第二个参数为虚拟dom时，格式为：h('div',h('span'))\r\n      }\r\n      return createVNode(type, propsOrChildren) // 当第二个参数为props时， 格式为： h('div',{color:red})\r\n    } else {\r\n      return createVNode(type, null, propsOrChildren);\r\n    }\r\n  } else {\r\n    if (l > 3) {\r\n      children = Array.prototype.slice.call(arguments, 2); // 获取第三个（包含第三个）参数，并组成一个数组\r\n    } else if (l === 3 && isVNode(children)) { // 参数长度为3，并且类型为虚拟dom，把它包装成数组格式\r\n      children = [children]\r\n    }\r\n    return createVNode(type, propsOrChildren, children) \r\n  }\r\n}\r\n\r\nconst createVNode = (type, props, children = null) => {\r\n  return _createVNode(type, props, children)\r\n}\r\n\r\nconst createBaseVNode = (type, props = null, children = null, shapeFlag, needFullChildrenNormalization = false) => {\r\n  const vnode = {\r\n    _v_isVNode: true,\r\n    type,\r\n    props,\r\n    children,\r\n    shapeFlag: shapeFlag,\r\n    component: null,\r\n    el: null,\r\n  }\r\n  if (needFullChildrenNormalization) {\r\n    normalizeChildren(vnode, children)\r\n  } else if (children) {\r\n    vnode.shapeFlag |= (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isString)(children)\r\n      ? ShapeFlags.TEXT_CHILDREN\r\n      : ShapeFlags.ARRAY_CHILDREN\r\n  }\r\n  return vnode\r\n}\r\n\r\nconst normalizeVNode = (child) => {\r\n  if (child == null || typeof child === 'boolean') {\r\n    // empty placeholder\r\n    return createVNode(Types.Comment)\r\n  } else if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(child)) {\r\n    // fragment\r\n    return createVNode(Types.Fragment, null, child.slice())\r\n  } else if (typeof child === 'object') {\r\n    // already vnode, this should be the most common since compiled templates\r\n    // always produce all-vnode children arrays\r\n    return cloneIfMounted(child)\r\n  } else {\r\n    // strings and numbers\r\n    return createVNode(Text, null, String(child))\r\n  }\r\n}\r\n\r\nconst cloneIfMounted = (child) => {\r\n  return (child.el === null)\r\n    ? child\r\n    : cloneVNode(child)\r\n}\r\n\r\nconst cloneVNode = (vnode) => {\r\n  const { props, children } = vnode\r\n  const cloned = {\r\n    __v_isVNode: true,\r\n    props: props,\r\n    type: vnode.type,\r\n    children: (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(children) ? children.map(deepCloneVNode) : children,\r\n    shapeFlag: vnode.shapeFlag,\r\n    appContext: vnode.appContext,\r\n    component: vnode.component,\r\n    el: vnode.el,\r\n    ctx: vnode.ctx\r\n  }\r\n  return cloned\r\n}\r\n\r\nconst deepCloneVNode = (vnode) => {\r\n  const cloned = cloneVNode(vnode)\r\n  if ((0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(vnode.children)) {\r\n    cloned.children = (vnode.children).map(deepCloneVNode)\r\n  }\r\n  return cloned\r\n}\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/vnode.js?");

/***/ }),

/***/ "./packages/core/dist/vue.js":
/*!***********************************!*\
  !*** ./packages/core/dist/vue.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createApp: () => (/* binding */ createApp),\n/* harmony export */   h: () => (/* reexport safe */ _vnode_js__WEBPACK_IMPORTED_MODULE_1__.h),\n/* harmony export */   reactive: () => (/* reexport safe */ _reactive_js__WEBPACK_IMPORTED_MODULE_5__.reactive)\n/* harmony export */ });\n/* harmony import */ var _render_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render.js */ \"./packages/core/dist/render.js\");\n/* harmony import */ var _vnode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnode.js */ \"./packages/core/dist/vnode.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ \"./packages/core/dist/dom.js\");\n/* harmony import */ var _patchprop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./patchprop.js */ \"./packages/core/dist/patchprop.js\");\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared.js */ \"./packages/core/dist/shared.js\");\n/* harmony import */ var _reactive_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reactive.js */ \"./packages/core/dist/reactive.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst createApp = (...args) => {\r\n  const app = createRender().createApp(...args)\r\n  const { mount } = app\r\n  const { normalizeContainer } = _dom_js__WEBPACK_IMPORTED_MODULE_2__.nodeOps\r\n  app.mount = (el) => {\r\n    const container = normalizeContainer(el)\r\n    if (!container) return\r\n    container.innerHTML = ''\r\n    const proxy = mount(container)\r\n    return proxy\r\n  }\r\n  return app\r\n}\r\n\r\nconst renderOption = (0,_shared_js__WEBPACK_IMPORTED_MODULE_4__.extend)({ patchProp: _patchprop_js__WEBPACK_IMPORTED_MODULE_3__.patchProp }, _dom_js__WEBPACK_IMPORTED_MODULE_2__.nodeOps)\r\nconst createRender = () => {\r\n  return (0,_render_js__WEBPACK_IMPORTED_MODULE_0__.baseCreateRenderer)(renderOption)\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://test-hand-write-vue/./packages/core/dist/vue.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var hand_write_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hand-write-vue */ \"./packages/core/dist/index.js\");\n\r\n// import HelloWorld from './HelloWorld.js'\r\n\r\nconst app = {\r\n  setup() {\r\n    const state = (0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({\r\n      count: 123,\r\n      message: 'hello from vue'\r\n    })\r\n    const handleIncr = () => {\r\n      state.count++\r\n    }\r\n    const handleDecr = () => {\r\n      state.count--\r\n    }\r\n    return function render() {\r\n      return (0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {class: 'wrapper'}, [\r\n        // h('div', '这是固定的'),\r\n        // h('h1', `这条消息来自${state.message}`),\r\n        (0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.h)('p', state.count),\r\n        (0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.h)('button', {'onClick': handleIncr}, 'INCR'),\r\n        (0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.h)('button', {class: 'primary', 'onClick': handleDecr}, 'DECR'),\r\n        // h(HelloWorld, {title: '666'})\r\n      ])\r\n    }\r\n  }\r\n}\r\n\r\n;(0,hand_write_vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(app).mount('#app')\n\n//# sourceURL=webpack://test-hand-write-vue/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;